{
    "sourceFile": "src/main/java/com/mygg/entities/Player.java",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 4,
            "patches": [
                {
                    "date": 1764385462495,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1764394339743,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,36 +1,49 @@\n package com.mygg.entities;\r\n \r\n-import java.util.HashMap;\r\n-\r\n import com.mygg.render.SpriteAnimation;\r\n+import com.mygg.render.SpriteLoader;\r\n \r\n import javafx.scene.image.Image;\r\n \r\n public class Player {\r\n \r\n-    public double x = 200, y = 200;\r\n-    public double speed = 120;\r\n+    public double x, y;\r\n+    public double speed = 90;\r\n \r\n-    public enum State { IDLE, WALK, PLACE, DEAD }\r\n+    public enum State { IDLE, WALK, PLACE }\r\n+    public State state = State.IDLE;\r\n+\r\n     public enum Direction { DOWN, UP, LEFT, RIGHT }\r\n-\r\n-    public State state = State.IDLE;\r\n     public Direction dir = Direction.DOWN;\r\n \r\n-    public HashMap<String, SpriteAnimation> anims = new HashMap<>();\r\n+    private final SpriteAnimation animIdleDown;\r\n+    private final SpriteAnimation animWalkDown;\r\n+    private final SpriteAnimation animWalkUp;\r\n+    private final SpriteAnimation animWalkLeft;\r\n+    private final SpriteAnimation animWalkRight;\r\n \r\n-    public void addAnim(String key, SpriteAnimation anim) {\r\n-        anims.put(key, anim);\r\n+    public Player(SpriteLoader loader) {\r\n+        animIdleDown = new SpriteAnimation(loader, \"idle_down\", 4, 0.7);\r\n+        animWalkDown = new SpriteAnimation(loader, \"walk_down\", 4, 0.15);\r\n+        animWalkUp = new SpriteAnimation(loader, \"walk_up\", 4, 0.15);\r\n+        animWalkLeft = new SpriteAnimation(loader, \"walk_left\", 4, 0.15);\r\n+        animWalkRight = new SpriteAnimation(loader, \"walk_right\", 4, 0.15);\r\n     }\r\n \r\n     public Image update(double dt) {\r\n-        String key = switch (state) {\r\n-            case IDLE -> \"idle_\" + dir.name().toLowerCase();\r\n-            case WALK -> \"walk_\" + dir.name().toLowerCase();\r\n-            case PLACE -> \"place_bom\";\r\n-            case DEAD -> \"death\";\r\n+\r\n+        return switch (state) {\r\n+\r\n+            case IDLE -> animIdleDown.frame(0);\r\n+\r\n+            case WALK -> switch (dir) {\r\n+                case DOWN -> animWalkDown.next(dt);\r\n+                case UP -> animWalkUp.next(dt);\r\n+                case LEFT -> animWalkLeft.next(dt);\r\n+                case RIGHT -> animWalkRight.next(dt);\r\n+            };\r\n+\r\n+            default -> animIdleDown.frame(0);\r\n         };\r\n-\r\n-        return anims.get(key).update(dt);\r\n     }\r\n }\r\n"
                },
                {
                    "date": 1764394711087,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,49 +1,120 @@\n package com.mygg.entities;\r\n \r\n import com.mygg.render.SpriteAnimation;\r\n import com.mygg.render.SpriteLoader;\r\n-\r\n import javafx.scene.image.Image;\r\n \r\n+/**\r\n+ * Player entity: posisi, speed, state, and animations.\r\n+ * Compatible with:\r\n+ *  - SpriteLoader.get(name) -> Image (WritableImage)\r\n+ *  - SpriteAnimation(Image... frames)\r\n+ */\r\n public class Player {\r\n \r\n-    public double x, y;\r\n-    public double speed = 90;\r\n+    public double x = 32;   // start position (pixel)\r\n+    public double y = 32;\r\n+    public double speed = 120; // pixels per second\r\n \r\n-    public enum State { IDLE, WALK, PLACE }\r\n+    public enum State { IDLE, WALK, PLACE, DEAD }\r\n+    public enum Direction { DOWN, UP, LEFT, RIGHT }\r\n+\r\n     public State state = State.IDLE;\r\n-\r\n-    public enum Direction { DOWN, UP, LEFT, RIGHT }\r\n     public Direction dir = Direction.DOWN;\r\n \r\n+    // Animations\r\n     private final SpriteAnimation animIdleDown;\r\n+    private final SpriteAnimation animIdleUp;\r\n+    private final SpriteAnimation animIdleLeft;\r\n+    private final SpriteAnimation animIdleRight;\r\n+\r\n     private final SpriteAnimation animWalkDown;\r\n     private final SpriteAnimation animWalkUp;\r\n     private final SpriteAnimation animWalkLeft;\r\n     private final SpriteAnimation animWalkRight;\r\n \r\n+    // --- Constructor: build animations from SpriteLoader ---\r\n     public Player(SpriteLoader loader) {\r\n-        animIdleDown = new SpriteAnimation(loader, \"idle_down\", 4, 0.7);\r\n-        animWalkDown = new SpriteAnimation(loader, \"walk_down\", 4, 0.15);\r\n-        animWalkUp = new SpriteAnimation(loader, \"walk_up\", 4, 0.15);\r\n-        animWalkLeft = new SpriteAnimation(loader, \"walk_left\", 4, 0.15);\r\n-        animWalkRight = new SpriteAnimation(loader, \"walk_right\", 4, 0.15);\r\n+        // Idle (single frame each direction) — using first idle frame if sprites had multiple\r\n+        animIdleDown = new SpriteAnimation(loadFrames(loader, \"idle_down\", 1));\r\n+        animIdleUp   = new SpriteAnimation(loadFrames(loader, \"idle_up\", 1));\r\n+        animIdleLeft = new SpriteAnimation(loadFrames(loader, \"idle_left\", 1));\r\n+        animIdleRight= new SpriteAnimation(loadFrames(loader, \"idle_right\", 1));\r\n+\r\n+        // Walk (multiple frames)\r\n+        animWalkDown = new SpriteAnimation(loadFrames(loader, \"walk_down\", 4));\r\n+        animWalkUp   = new SpriteAnimation(loadFrames(loader, \"walk_up\", 4));\r\n+        animWalkLeft = new SpriteAnimation(loadFrames(loader, \"walk_left\", 3));\r\n+        animWalkRight= new SpriteAnimation(loadFrames(loader, \"walk_right\", 4));\r\n     }\r\n \r\n-    public Image update(double dt) {\r\n+    /**\r\n+     * Helper: load frames from loader using naming pattern base1, base2, ... baseN.\r\n+     * If a frame not found (null), it's skipped (keeps array length consistent with found frames).\r\n+     */\r\n+    private Image[] loadFrames(SpriteLoader loader, String base, int count) {\r\n+        // Collect into temporary array, allow missing frames\r\n+        Image[] tmp = new Image[count];\r\n+        int found = 0;\r\n+        for (int i = 1; i <= count; i++) {\r\n+            String key = base + i;       // e.g. \"walk_down1\"\r\n+            Image img = loader.get(key); // loader.get returns WritableImage (Image subclass)\r\n+            if (img != null) {\r\n+                tmp[found++] = img;\r\n+            } else {\r\n+                // If a numbered frame missing, try without number (for single-frame idle names like \"idle_down\")\r\n+                if (i == 1) {\r\n+                    Image alt = loader.get(base); // try \"idle_down\"\r\n+                    if (alt != null) {\r\n+                        tmp[found++] = alt;\r\n+                    }\r\n+                }\r\n+                // otherwise just skip\r\n+            }\r\n+        }\r\n \r\n-        return switch (state) {\r\n+        // If none found, return a 1-length array with a blank 1x1 image to avoid NPE\r\n+        if (found == 0) {\r\n+            return new Image[] { new javafx.scene.image.WritableImage(1,1) };\r\n+        }\r\n \r\n-            case IDLE -> animIdleDown.frame(0);\r\n+        // shrink array to found length\r\n+        Image[] frames = new Image[found];\r\n+        System.arraycopy(tmp, 0, frames, 0, found);\r\n+        return frames;\r\n+    }\r\n \r\n-            case WALK -> switch (dir) {\r\n-                case DOWN -> animWalkDown.next(dt);\r\n-                case UP -> animWalkUp.next(dt);\r\n-                case LEFT -> animWalkLeft.next(dt);\r\n-                case RIGHT -> animWalkRight.next(dt);\r\n-            };\r\n+    /**\r\n+     * Update animation state and return the current Image frame to draw.\r\n+     * GameCanvas will call this each render tick.\r\n+     *\r\n+     * @param dt delta time in seconds (unused for idle frame but passed to animation)\r\n+     * @return Image current frame\r\n+     */\r\n+    public Image update(double dt) {\r\n \r\n-            default -> animIdleDown.frame(0);\r\n-        };\r\n+        // choose animation based on state + direction\r\n+        if (state == State.IDLE) {\r\n+            switch (dir) {\r\n+                case DOWN:  return animIdleDown.update(dt);\r\n+                case UP:    return animIdleUp.update(dt);\r\n+                case LEFT:  return animIdleLeft.update(dt);\r\n+                case RIGHT: return animIdleRight.update(dt);\r\n+                default:    return animIdleDown.update(dt);\r\n+            }\r\n+        } else if (state == State.WALK) {\r\n+            switch (dir) {\r\n+                case DOWN:  return animWalkDown.update(dt);\r\n+                case UP:    return animWalkUp.update(dt);\r\n+                case LEFT:  return animWalkLeft.update(dt);\r\n+                case RIGHT: return animWalkRight.update(dt);\r\n+                default:    return animWalkDown.update(dt);\r\n+            }\r\n+        } else if (state == State.PLACE) {\r\n+            // fallback: show idle down frame if no place animation\r\n+            return animIdleDown.update(dt);\r\n+        } else { // DEAD or others\r\n+            return animIdleDown.update(dt);\r\n+        }\r\n     }\r\n }\r\n"
                },
                {
                    "date": 1764394799282,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,121 +1,69 @@\n-package com.mygg.entities;\r\n+package com.mygg.core;\r\n \r\n-import com.mygg.render.SpriteAnimation;\r\n-import com.mygg.render.SpriteLoader;\r\n+import javafx.scene.input.KeyEvent;\r\n+import javafx.scene.input.KeyCode;\r\n \r\n-import javafx.scene.image.Image;\r\n+public class InputHandler {\r\n \r\n-/**\r\n- * Player entity: posisi, speed, state, and animations.\r\n- * Compatible with:\r\n- *  - SpriteLoader.get(name) -> Image (WritableImage)\r\n- *  - SpriteAnimation(Image... frames)\r\n- */\r\n-public class Player {\r\n+    public boolean up, down, left, right, place;\r\n \r\n-    public double x = 32;   // start position (pixel)\r\n-    public double y = 32;\r\n-    public double speed = 120; // pixels per second\r\n+    public void keyDown(KeyEvent e) {\r\n+        KeyCode code = e.getCode();\r\n \r\n-    public enum State { IDLE, WALK, PLACE, DEAD }\r\n-    public enum Direction { DOWN, UP, LEFT, RIGHT }\r\n+        switch (code) {\r\n+            case W:\r\n+            case UP:\r\n+                up = true;\r\n+                break;\r\n \r\n-    public State state = State.IDLE;\r\n-    public Direction dir = Direction.DOWN;\r\n+            case S:\r\n+            case DOWN:\r\n+                down = true;\r\n+                break;\r\n \r\n-    // Animations\r\n-    private final SpriteAnimation animIdleDown;\r\n-    private final SpriteAnimation animIdleUp;\r\n-    private final SpriteAnimation animIdleLeft;\r\n-    private final SpriteAnimation animIdleRight;\r\n+            case A:\r\n+            case LEFT:\r\n+                left = true;\r\n+                break;\r\n \r\n-    private final SpriteAnimation animWalkDown;\r\n-    private final SpriteAnimation animWalkUp;\r\n-    private final SpriteAnimation animWalkLeft;\r\n-    private final SpriteAnimation animWalkRight;\r\n+            case D:\r\n+            case RIGHT:\r\n+                right = true;\r\n+                break;\r\n \r\n-    // --- Constructor: build animations from SpriteLoader ---\r\n-    public Player(SpriteLoader loader) {\r\n-        // Idle (single frame each direction) — using first idle frame if sprites had multiple\r\n-        animIdleDown = new SpriteAnimation(loadFrames(loader, \"idle_down\", 1));\r\n-        animIdleUp   = new SpriteAnimation(loadFrames(loader, \"idle_up\", 1));\r\n-        animIdleLeft = new SpriteAnimation(loadFrames(loader, \"idle_left\", 1));\r\n-        animIdleRight= new SpriteAnimation(loadFrames(loader, \"idle_right\", 1));\r\n-\r\n-        // Walk (multiple frames)\r\n-        animWalkDown = new SpriteAnimation(loadFrames(loader, \"walk_down\", 4));\r\n-        animWalkUp   = new SpriteAnimation(loadFrames(loader, \"walk_up\", 4));\r\n-        animWalkLeft = new SpriteAnimation(loadFrames(loader, \"walk_left\", 3));\r\n-        animWalkRight= new SpriteAnimation(loadFrames(loader, \"walk_right\", 4));\r\n+            case SPACE:\r\n+                place = true;\r\n+                break;\r\n+        }\r\n     }\r\n \r\n-    /**\r\n-     * Helper: load frames from loader using naming pattern base1, base2, ... baseN.\r\n-     * If a frame not found (null), it's skipped (keeps array length consistent with found frames).\r\n-     */\r\n-    private Image[] loadFrames(SpriteLoader loader, String base, int count) {\r\n-        // Collect into temporary array, allow missing frames\r\n-        Image[] tmp = new Image[count];\r\n-        int found = 0;\r\n-        for (int i = 1; i <= count; i++) {\r\n-            String key = base + i;       // e.g. \"walk_down1\"\r\n-            Image img = loader.get(key); // loader.get returns WritableImage (Image subclass)\r\n-            if (img != null) {\r\n-                tmp[found++] = img;\r\n-            } else {\r\n-                // If a numbered frame missing, try without number (for single-frame idle names like \"idle_down\")\r\n-                if (i == 1) {\r\n-                    Image alt = loader.get(base); // try \"idle_down\"\r\n-                    if (alt != null) {\r\n-                        tmp[found++] = alt;\r\n-                    }\r\n-                }\r\n-                // otherwise just skip\r\n-            }\r\n-        }\r\n+    public void keyUp(KeyEvent e) {\r\n+        KeyCode code = e.getCode();\r\n \r\n-        // If none found, return a 1-length array with a blank 1x1 image to avoid NPE\r\n-        if (found == 0) {\r\n-            return new Image[] { new javafx.scene.image.WritableImage(1,1) };\r\n-        }\r\n+        switch (code) {\r\n+            case W:\r\n+            case UP:\r\n+                up = false;\r\n+                break;\r\n \r\n-        // shrink array to found length\r\n-        Image[] frames = new Image[found];\r\n-        System.arraycopy(tmp, 0, frames, 0, found);\r\n-        return frames;\r\n-    }\r\n+            case S:\r\n+            case DOWN:\r\n+                down = false;\r\n+                break;\r\n \r\n-    /**\r\n-     * Update animation state and return the current Image frame to draw.\r\n-     * GameCanvas will call this each render tick.\r\n-     *\r\n-     * @param dt delta time in seconds (unused for idle frame but passed to animation)\r\n-     * @return Image current frame\r\n-     */\r\n-    public Image update(double dt) {\r\n+            case A:\r\n+            case LEFT:\r\n+                left = false;\r\n+                break;\r\n \r\n-        // choose animation based on state + direction\r\n-        if (state == State.IDLE) {\r\n-            switch (dir) {\r\n-                case DOWN:  return animIdleDown.update(dt);\r\n-                case UP:    return animIdleUp.update(dt);\r\n-                case LEFT:  return animIdleLeft.update(dt);\r\n-                case RIGHT: return animIdleRight.update(dt);\r\n-                default:    return animIdleDown.update(dt);\r\n-            }\r\n-        } else if (state == State.WALK) {\r\n-            switch (dir) {\r\n-                case DOWN:  return animWalkDown.update(dt);\r\n-                case UP:    return animWalkUp.update(dt);\r\n-                case LEFT:  return animWalkLeft.update(dt);\r\n-                case RIGHT: return animWalkRight.update(dt);\r\n-                default:    return animWalkDown.update(dt);\r\n-            }\r\n-        } else if (state == State.PLACE) {\r\n-            // fallback: show idle down frame if no place animation\r\n-            return animIdleDown.update(dt);\r\n-        } else { // DEAD or others\r\n-            return animIdleDown.update(dt);\r\n+            case D:\r\n+            case RIGHT:\r\n+                right = false;\r\n+                break;\r\n+\r\n+            case SPACE:\r\n+                place = false;\r\n+                break;\r\n         }\r\n     }\r\n }\r\n"
                },
                {
                    "date": 1764394814849,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,69 +1,121 @@\n-package com.mygg.core;\r\n+package com.mygg.entities;\r\n \r\n-import javafx.scene.input.KeyEvent;\r\n-import javafx.scene.input.KeyCode;\r\n+import com.mygg.render.SpriteAnimation;\r\n+import com.mygg.render.SpriteLoader;\r\n \r\n-public class InputHandler {\r\n+import javafx.scene.image.Image;\r\n \r\n-    public boolean up, down, left, right, place;\r\n+/**\r\n+ * Player entity: posisi, speed, state, and animations.\r\n+ * Compatible with:\r\n+ *  - SpriteLoader.get(name) -> Image (WritableImage)\r\n+ *  - SpriteAnimation(Image... frames)\r\n+ */\r\n+public class Player {\r\n \r\n-    public void keyDown(KeyEvent e) {\r\n-        KeyCode code = e.getCode();\r\n+    public double x = 32;   // start position (pixel)\r\n+    public double y = 32;\r\n+    public double speed = 120; // pixels per second\r\n \r\n-        switch (code) {\r\n-            case W:\r\n-            case UP:\r\n-                up = true;\r\n-                break;\r\n+    public enum State { IDLE, WALK, PLACE, DEAD }\r\n+    public enum Direction { DOWN, UP, LEFT, RIGHT }\r\n \r\n-            case S:\r\n-            case DOWN:\r\n-                down = true;\r\n-                break;\r\n+    public State state = State.IDLE;\r\n+    public Direction dir = Direction.DOWN;\r\n \r\n-            case A:\r\n-            case LEFT:\r\n-                left = true;\r\n-                break;\r\n+    // Animations\r\n+    private final SpriteAnimation animIdleDown;\r\n+    private final SpriteAnimation animIdleUp;\r\n+    private final SpriteAnimation animIdleLeft;\r\n+    private final SpriteAnimation animIdleRight;\r\n \r\n-            case D:\r\n-            case RIGHT:\r\n-                right = true;\r\n-                break;\r\n+    private final SpriteAnimation animWalkDown;\r\n+    private final SpriteAnimation animWalkUp;\r\n+    private final SpriteAnimation animWalkLeft;\r\n+    private final SpriteAnimation animWalkRight;\r\n \r\n-            case SPACE:\r\n-                place = true;\r\n-                break;\r\n-        }\r\n+    // --- Constructor: build animations from SpriteLoader ---\r\n+    public Player(SpriteLoader loader) {\r\n+        // Idle (single frame each direction) — using first idle frame if sprites had multiple\r\n+        animIdleDown = new SpriteAnimation(loadFrames(loader, \"idle_down\", 1));\r\n+        animIdleUp   = new SpriteAnimation(loadFrames(loader, \"idle_up\", 1));\r\n+        animIdleLeft = new SpriteAnimation(loadFrames(loader, \"idle_left\", 1));\r\n+        animIdleRight= new SpriteAnimation(loadFrames(loader, \"idle_right\", 1));\r\n+\r\n+        // Walk (multiple frames)\r\n+        animWalkDown = new SpriteAnimation(loadFrames(loader, \"walk_down\", 4));\r\n+        animWalkUp   = new SpriteAnimation(loadFrames(loader, \"walk_up\", 4));\r\n+        animWalkLeft = new SpriteAnimation(loadFrames(loader, \"walk_left\", 3));\r\n+        animWalkRight= new SpriteAnimation(loadFrames(loader, \"walk_right\", 4));\r\n     }\r\n \r\n-    public void keyUp(KeyEvent e) {\r\n-        KeyCode code = e.getCode();\r\n+    /**\r\n+     * Helper: load frames from loader using naming pattern base1, base2, ... baseN.\r\n+     * If a frame not found (null), it's skipped (keeps array length consistent with found frames).\r\n+     */\r\n+    private Image[] loadFrames(SpriteLoader loader, String base, int count) {\r\n+        // Collect into temporary array, allow missing frames\r\n+        Image[] tmp = new Image[count];\r\n+        int found = 0;\r\n+        for (int i = 1; i <= count; i++) {\r\n+            String key = base + i;       // e.g. \"walk_down1\"\r\n+            Image img = loader.get(key); // loader.get returns WritableImage (Image subclass)\r\n+            if (img != null) {\r\n+                tmp[found++] = img;\r\n+            } else {\r\n+                // If a numbered frame missing, try without number (for single-frame idle names like \"idle_down\")\r\n+                if (i == 1) {\r\n+                    Image alt = loader.get(base); // try \"idle_down\"\r\n+                    if (alt != null) {\r\n+                        tmp[found++] = alt;\r\n+                    }\r\n+                }\r\n+                // otherwise just skip\r\n+            }\r\n+        }\r\n \r\n-        switch (code) {\r\n-            case W:\r\n-            case UP:\r\n-                up = false;\r\n-                break;\r\n+        // If none found, return a 1-length array with a blank 1x1 image to avoid NPE\r\n+        if (found == 0) {\r\n+            return new Image[] { new javafx.scene.image.WritableImage(1,1) };\r\n+        }\r\n \r\n-            case S:\r\n-            case DOWN:\r\n-                down = false;\r\n-                break;\r\n+        // shrink array to found length\r\n+        Image[] frames = new Image[found];\r\n+        System.arraycopy(tmp, 0, frames, 0, found);\r\n+        return frames;\r\n+    }\r\n \r\n-            case A:\r\n-            case LEFT:\r\n-                left = false;\r\n-                break;\r\n+    /**\r\n+     * Update animation state and return the current Image frame to draw.\r\n+     * GameCanvas will call this each render tick.\r\n+     *\r\n+     * @param dt delta time in seconds (unused for idle frame but passed to animation)\r\n+     * @return Image current frame\r\n+     */\r\n+    public Image update(double dt) {\r\n \r\n-            case D:\r\n-            case RIGHT:\r\n-                right = false;\r\n-                break;\r\n-\r\n-            case SPACE:\r\n-                place = false;\r\n-                break;\r\n+        // choose animation based on state + direction\r\n+        if (state == State.IDLE) {\r\n+            switch (dir) {\r\n+                case DOWN:  return animIdleDown.update(dt);\r\n+                case UP:    return animIdleUp.update(dt);\r\n+                case LEFT:  return animIdleLeft.update(dt);\r\n+                case RIGHT: return animIdleRight.update(dt);\r\n+                default:    return animIdleDown.update(dt);\r\n+            }\r\n+        } else if (state == State.WALK) {\r\n+            switch (dir) {\r\n+                case DOWN:  return animWalkDown.update(dt);\r\n+                case UP:    return animWalkUp.update(dt);\r\n+                case LEFT:  return animWalkLeft.update(dt);\r\n+                case RIGHT: return animWalkRight.update(dt);\r\n+                default:    return animWalkDown.update(dt);\r\n+            }\r\n+        } else if (state == State.PLACE) {\r\n+            // fallback: show idle down frame if no place animation\r\n+            return animIdleDown.update(dt);\r\n+        } else { // DEAD or others\r\n+            return animIdleDown.update(dt);\r\n         }\r\n     }\r\n }\r\n"
                }
            ],
            "date": 1764385462495,
            "name": "Commit-0",
            "content": "package com.mygg.entities;\r\n\r\nimport java.util.HashMap;\r\n\r\nimport com.mygg.render.SpriteAnimation;\r\n\r\nimport javafx.scene.image.Image;\r\n\r\npublic class Player {\r\n\r\n    public double x = 200, y = 200;\r\n    public double speed = 120;\r\n\r\n    public enum State { IDLE, WALK, PLACE, DEAD }\r\n    public enum Direction { DOWN, UP, LEFT, RIGHT }\r\n\r\n    public State state = State.IDLE;\r\n    public Direction dir = Direction.DOWN;\r\n\r\n    public HashMap<String, SpriteAnimation> anims = new HashMap<>();\r\n\r\n    public void addAnim(String key, SpriteAnimation anim) {\r\n        anims.put(key, anim);\r\n    }\r\n\r\n    public Image update(double dt) {\r\n        String key = switch (state) {\r\n            case IDLE -> \"idle_\" + dir.name().toLowerCase();\r\n            case WALK -> \"walk_\" + dir.name().toLowerCase();\r\n            case PLACE -> \"place_bom\";\r\n            case DEAD -> \"death\";\r\n        };\r\n\r\n        return anims.get(key).update(dt);\r\n    }\r\n}\r\n"
        }
    ]
}